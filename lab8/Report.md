# Lab8 文件系统

## 练习1: 完成读文件操作的实现
**首先了解打开文件的处理流程，然后参考本实验后续的文件读写操作的过程分析，填写在 kern/fs/sfs/sfs_inode.c中 的sfs_io_nolock()函数，实现读文件中数据的代码。**

sfs_io_nolock()函数的主要作用是在不加锁的情况下，根据 offset 和 alenp 指定的长度，从指定的 inode 读取数据到 buf，或者将 buf 的数据写入文件（由 write 参数决定）

读写文件操作流程分析
1. 首先，函数会根据 offset 和 alenp 计算实际可操作的字节数，防止越界访问。
2. 读写操作都需要根据 offset 计算出起始的块号和块内偏移，然后循环处理每个块的数据。
3. 每次循环时，先通过 sfs_bmap() 获取对应的物理块号。
    - 读操作：通过 sfs_rbuf() 或 sfs_rblock() 读取块内容到临时缓冲区，再 memcpy 到用户 buf。
    - 写操作：通过 sfs_wbuf() 或 sfs_wblock() 获取块缓冲区，先读出原有数据，再将 buf 的内容写入缓冲区，最后标记为脏页。
4. 需要处理跨块读写的情况，即一次操作可能会跨越多个磁盘块。
5. 每次处理后，更新 buf 指针、offset 和剩余要操作的字节数，直到全部完成或遇到文件末尾或写满。


## 练习2: 完成基于文件系统的执行程序机制的实现
**改写proc.c中的load_icode函数和其他相关函数，实现基于文件系统的执行程序机制。执行：make qemu。如果能看看到sh用户程序的执行界面，则基本成功了。如果在sh用户界面上可以执行exit, hello（更多用户程序放在user目录下）等其他放置在sfs文件系统中的其他执行程序，则可以认为本实验基本成功。**



## 扩展练习 Challenge1：完成基于“UNIX的PIPE机制”的设计方案
**如果要在ucore里加入UNIX的管道（Pipe）机制，至少需要定义哪些数据结构和接口？（接口给出语义即可，不必具体实现。数据结构的设计应当给出一个（或多个）具体的C语言struct定义。在网络上查找相关的Linux资料和实现，请在实验报告中给出设计实现”UNIX的PIPE机制“的概要设方案，你的设计应当体现出对可能出现的同步互斥问题的处理。）**

### 需要定义的数据结构

UNIX 的管道本质上是一个内核缓冲区，支持进程间的单向通信。为实现 pipe，需要定义如下核心数据结构：

```c
#define PIPE_BUF 4096

struct pipe {
    char buffer[PIPE_BUF];      // 管道缓冲区
    size_t read_pos;            // 读指针
    size_t write_pos;           // 写指针
    size_t data_size;           // 当前缓冲区内数据量
    int read_open;              // 读端是否打开
    int write_open;             // 写端是否打开
    struct sleep_queue *rq;     // 读等待队列
    struct sleep_queue *wq;     // 写等待队列
    struct lock pipe_lock;      // 管道互斥锁
};
```

每个 pipe 结构体代表一个管道对象，包含缓冲区、读写指针、同步队列和互斥锁等。

### 需要定义的接口

- `int pipe_create(struct pipe **p)`
    - 创建一个新的管道，初始化相关数据结构。
- `ssize_t pipe_read(struct pipe *p, void *buf, size_t len)`
    - 从管道中读取数据到 buf，返回实际读取的字节数。如果没有数据可读，则阻塞等待。
- `ssize_t pipe_write(struct pipe *p, const void *buf, size_t len)`
    - 向管道中写入数据，如果缓冲区满则阻塞等待。
- `int pipe_close_read(struct pipe *p)`
    - 关闭管道的读端，释放相关资源。
- `int pipe_close_write(struct pipe *p)`
    - 关闭管道的写端，释放相关资源。

### 同步互斥问题的处理

- 使用互斥锁 `pipe_lock` 来保护对管道缓冲区和指针的访问，防止并发读写导致数据不一致。
- 使用睡眠队列 `rq` 和 `wq` 来实现读写阻塞，当读操作发现没有数据可读时，将进程加入读等待队列并阻塞；当写操作发现缓冲区满时，将进程加入写等待队列并阻塞。
- 在读写操作完成后，唤醒相应的等待队列中的进程，确保数据流畅传输。

## 扩展练习 Challenge2：完成基于“UNIX的软连接和硬连接机制”的设计方案
**如果要在ucore里加入UNIX的软连接和硬连接机制，至少需要定义哪些数据结构和接口？（接口给出语义即可，不必具体实现。数据结构的设计应当给出一个（或多个）具体的C语言struct定义。在网络上查找相关的Linux资料和实现，请在实验报告中给出设计实现”UNIX的软连接和硬连接机制“的概要设方案，你的设计应当体现出对可能出现的同步互斥问题的处理。）**

### 需要定义的数据结构

#### 1. inode结构体扩展
硬连接本质上是多个目录项指向同一个 inode，因此需要使用 inode 结构体中引用计数：

```c
struct inode {
    ... // 其他成员
    uint32_t link_count; // 硬连接计数
    ... // 其他成员
};
```

#### 2. 目录项结构体
目录项需要区分普通文件、软连接和硬连接：

```c
#define FILE_TYPE_REG 1
#define FILE_TYPE_DIR 2
#define FILE_TYPE_SYMLINK 3

struct dir_entry {
    char name[MAX_NAME_LEN];
    uint32_t inode_no;
    uint32_t file_type; // 文件类型
};
```

#### 3. 软连接结构体
软连接是一个特殊的文件，内容为目标路径：

```c
struct symlink {
    char target_path[MAX_PATH_LEN]; // 软连接目标路径
};
```

### 需要定义的接口

- `int link(const char *oldpath, const char *newpath)`
  - 创建硬连接，使 newpath 指向 oldpath 的 inode，增加 link_count。
- `int unlink(const char *path)`
  - 删除一个目录项，若为硬连接则减少 link_count，link_count 为0时释放 inode。
- `int symlink(const char *target, const char *linkpath)`
  - 创建软连接，linkpath 为新建的符号链接文件，内容为 target 路径。
- `int readlink(const char *path, char *buf, size_t bufsiz)`
  - 读取软连接内容（目标路径）。
- 文件系统相关接口需支持识别和处理软连接与硬连接，如 open/read/write 等。

### 同步互斥问题的处理

- inode 的 link_count 修改需加锁，防止并发创建/删除硬连接导致计数错误。
- 软连接的创建和读取也需加锁，防止并发访问导致数据不一致。
- 目录项的修改（如添加/删除链接）需加锁，保证文件系统一致性。

## 实验中重要的知识点及其与OS原理的关系

1. **文件系统的实现与管理**
    - **实验知识点**：实现文件的读写、文件系统的挂载、inode管理、块映射、目录项操作、软/硬链接机制。
    - **OS原理知识点**：文件系统抽象、inode结构、目录管理、文件访问控制、链接机制。
    - **理解**：实验通过具体实现SFS文件系统，让我们理解文件系统如何将文件抽象为inode、如何通过块映射管理磁盘空间、如何支持多种文件类型（普通文件、目录、链接）。原理部分更偏重于结构和机制的讲解，实验则让我们体会到实现细节和工程复杂性。

2. **进程与程序装载机制**
    - **实验知识点**：基于文件系统的程序加载（load_icode）、用户程序的执行、文件系统与进程管理的协作。
    - **OS原理知识点**：进程的创建与装载、地址空间管理、用户/内核态切换。
    - **理解**：实验让我们动手实现了从文件系统读取可执行文件并装载到内存的过程，体会到文件系统与进程管理的紧密结合。原理部分则强调进程生命周期、装载机制的理论。

3. **同步与互斥机制**
    - **实验知识点**：管道（pipe）机制的设计、锁与睡眠队列的使用、并发读写的同步。
    - **OS原理知识点**：临界区、互斥锁、条件变量、进程/线程同步。
    - **理解**：实验通过管道机制的设计，要求我们考虑并发读写时的同步互斥问题。原理部分则系统讲解了各种同步原语及其适用场景。

4. **链接机制（软链接与硬链接）**
    - **实验知识点**：软/硬链接的数据结构与接口设计、目录项与inode的关系。
    - **OS原理知识点**：文件系统中的链接、引用计数、路径解析。
    - **理解**：实验要求我们设计软/硬链接的实现方案，体会到链接对文件系统一致性和灵活性的影响。

5. **跨块读写与缓冲管理**
    - **实验知识点**：跨块读写的处理、块缓冲区的管理、数据一致性保障。
    - **OS原理知识点**：缓冲区管理、磁盘I/O调度、文件系统一致性。
    - **理解**：实验让我们关注实际读写操作中跨块、缓冲一致性等细节，原理部分则讲解了缓冲管理的策略和原理。

## 实验未覆盖但OS原理中重要的知识点

1. **文件系统的高级特性**
    - 日志型文件系统（Journaling）、快照（Snapshot）、配额管理、访问控制列表（ACL）等。

2. **磁盘调度算法**
    - 如电梯算法（Elevator）、最短寻道时间优先（SSTF）等，实验未涉及底层磁盘调度。

3. **安全与权限模型**
    - 细粒度的权限控制、SELinux等安全机制。

4. **文件系统的崩溃恢复与一致性保障**
    - 如日志恢复、写时复制（COW）等机制。
